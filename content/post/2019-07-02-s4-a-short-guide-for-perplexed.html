---
title: 'S4: a short guide for the perplexed'
author: Stuart Lee
date: '2019-07-02'
slug: s4-a-short-guide-for-perplexed
categories: [R, object-oriented-programming, Bioconductor, education]
tags: [R, education]
---



<p>I recently attended the <a href="http://bioc2019.bioconductor.org">Bioconductor 2019</a> conference in New York City, where
I was lucky enough to give a workshop on my Bioconductor package
<a href="https://www.bioconductor.org/packages/release/bioc/html/plyranges.html"><code>plyranges</code></a>
and present some <a href="https://github.com/sa-lee/superintronic">new ideas</a> I‚Äôm working
on range-based summarisation and visualisation. After some discussion with
both Bioconductor veterans and new-comers there was general agreement that it
was hard to find good resources or even a beginner‚Äôs guide for learning
S4. This blog-post is an attempt to rectify that.</p>
<div id="what-is-s4" class="section level2">
<h2>What is S4?</h2>
<p>S4 is a formal object oriented system in R. It‚Äôs implemented in the
<code>methods</code> package created by John Chambers and maintained by the R core team.
It also is one of several packages that ships with base R and is loaded on
start up.</p>
</div>
<div id="why-use-s4" class="section level2">
<h2>Why use S4?</h2>
<p>Compared to other object oriented paradigms in R, S4 requires a developer
to write classes that follow a strict structure - an S4 object has its
components defined upfront using slots. A well designed class can avoid code
duplication, and the strictness helps a developer to ensure
their code is correct.</p>
<p>Community is also a driver for using S4. The Bioconductor
project uses S4 extensively: there are standard classes in the
ecosystem to represent many types of ‚Äòomics‚Äô data. Developers and users alike
can reuse these classes and their associated methods without the need to
invent their own and enables interoperability between many different packages.</p>
<p>Learning to program with S4 can be daunting - especially for new users of R
or those who are used to the relative simplicity of the tidyverse ecosystem.
I remember being incredibly confused and overwhelmed when I started to learn
it (a lot of the documentation and guides are extremely technical) and found
myself reading a lot of other people‚Äôs code in order to figure out what on
earth is going on. From both a developer and user perspective, I think
the essence of S4 can be distilled into three principles.</p>
</div>
<div id="principle-1-its-all-about-the-abstraction" class="section level2">
<h2>Principle 1: it‚Äôs all about the abstraction</h2>
<blockquote class="twitter-tweet">
<p lang="en" dir="ltr">
S4 objects don't do anything; they are pure data. Accepting that is the first step towards mastery of OOP in <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a>.
</p>
‚Äî Michael Lawrence (<span class="citation">@lawremi</span>) <a href="https://twitter.com/lawremi/status/632273174160277504?ref_src=twsrc%5Etfw">August 14, 2015</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>The design of an S4 class is merely a way of setting up an abstraction for a data analysis
problem. This is often the hardest part of using S4, coming up with a
‚Äògood-enough‚Äô abstraction for the problem at hand.</p>
<p>Let‚Äôs try creating an S4 class for a <a href="https://en.wikipedia.org/wiki/Turtle_graphics">Turtle</a>.
A turtle can move in a path in two dimensions as illustrated below:</p>
<p><img src="/post/2019-07-02-s4-a-short-guide-for-perplexed_files/figure-html/unnamed-chunk-1-1.gif" /><!-- --></p>
<p>We can define a class to represent a Turtle as follows:</p>
<pre class="r"><code>library(methods)
setClass(&quot;Turtle&quot;, 
         slots = c(location = &quot;numeric&quot;, orientation = &quot;numeric&quot;, path = &quot;matrix&quot;)
)</code></pre>
<p>At a minimum an S4 class needs two things the name of the class
and a named character vector of slots. Slots define the data that forms
the class. In the case of the Turtle, we have three slots one representing
the turtle‚Äôs current location as a numeric vector, one representing
it‚Äôs current orientation (the angle that the turtle is facing), and finally
a matrix representing the path it‚Äôs travelled so far.</p>
<p>We can create an instance of a Turtle using <code>new</code>:</p>
<pre class="r"><code>lil_turtle &lt;- new(&quot;Turtle&quot;, 
                  location = c(0,0), 
                  orientation = 0,
                  path = matrix(c(0,0), ncol = 2))
lil_turtle</code></pre>
<pre><code>## An object of class &quot;Turtle&quot;
## Slot &quot;location&quot;:
## [1] 0 0
## 
## Slot &quot;orientation&quot;:
## [1] 0
## 
## Slot &quot;path&quot;:
##      [,1] [,2]
## [1,]    0    0</code></pre>
<p>Slots can be accessed using <code>@</code> but we will see later it‚Äôs better to define
functions called getters that access each component of the object.</p>
<pre class="r"><code>lil_turtle@location</code></pre>
<pre><code>## [1] 0 0</code></pre>
<pre class="r"><code>lil_turtle@orientation</code></pre>
<pre><code>## [1] 0</code></pre>
<p>We would like to ensure that when we create a new turtle
that it‚Äôs current location is always a numeric vector of length 2, and that
it‚Äôs orientation is in degrees between -360 to 360. We‚Äôll also
check that the path is a matrix with two columns. We can do this by creating
a function to check our turtle is valid:</p>
<pre><code>## Class &quot;Turtle&quot; [in &quot;.GlobalEnv&quot;]
## 
## Slots:
##                                           
## Name:     location orientation        path
## Class:     numeric     numeric      matrix</code></pre>
<p>Now we also need an interface to creating a new object of class Turtle, called
a constructor. Generally, this is a function that calls <code>new</code> and has
arguments corresponding to the slots of our object.</p>
<pre class="r"><code>Turtle &lt;- function(location = c(0,0), orientation = 0) {
  new(&quot;Turtle&quot;, 
      location = location, 
      orientation = orientation,
      path = matrix(location, ncol = 2))
}</code></pre>
<p>Calling <code>new</code> now that the validity is set, will check that the arguments
provided to the constructor result in a proper turtle. We haven‚Äôt included
an argument for the path, cause our Turtle hasn‚Äôt travelled anywhere yet‚Ä¶</p>
<p>So far we can‚Äôt do anything interesting with turtles, we need to define
some methods!</p>
</div>
<div id="principle-2-in-statistics-we-like-methods" class="section level2">
<h2>Principle 2: in statistics we like methods</h2>
<p>Both S3 and S4 use generic functions which is a little different from
other object-oriented programming languages. A generic function determines
how a method is called when an argument is a given class (or combination of classes).
In general, a generic function should be created if you plan to reuse it
for many distinct classes or if it will be useful to other package developers.</p>
<p>For example, we could create two generic functions that represent
a Turtle moving forward and a turtle turning.</p>
<pre class="r"><code>setGeneric(&quot;forward&quot;, 
           function(x, ...) standardGeneric(&quot;forward&quot;)
)</code></pre>
<pre><code>## [1] &quot;forward&quot;</code></pre>
<p>This creates a function called <code>forward</code> with an argument <code>x</code>, called
the signature of the generic and <code>...</code> which can be other arguments that
will determine how a turtle moves. The class of <code>x</code> changes which <code>forward</code>
method will be selected.</p>
<p>Similarly, we can implement a generic for reorienting.</p>
<pre class="r"><code>setGeneric(&quot;turn&quot;, function(x, ...) standardGeneric(&quot;turn&quot;))</code></pre>
<pre><code>## [1] &quot;turn&quot;</code></pre>
<p>To complete our interface, we will also create generics for accessing
and replacing each slot of our class.</p>
<pre class="r"><code>setGeneric(&quot;location&quot;, function(x) standardGeneric(&quot;location&quot;))</code></pre>
<pre><code>## [1] &quot;location&quot;</code></pre>
<pre class="r"><code>setGeneric(&quot;location&lt;-&quot;, function(x, value) standardGeneric(&quot;location&lt;-&quot;))</code></pre>
<pre><code>## [1] &quot;location&lt;-&quot;</code></pre>
<pre class="r"><code>setGeneric(&quot;orientation&quot;, function(x) standardGeneric(&quot;orientation&quot;))</code></pre>
<pre><code>## [1] &quot;orientation&quot;</code></pre>
<pre class="r"><code>setGeneric(&quot;orientation&lt;-&quot;, function(x, value) standardGeneric(&quot;orientation&lt;-&quot;))</code></pre>
<pre><code>## [1] &quot;orientation&lt;-&quot;</code></pre>
<pre class="r"><code>setGeneric(&quot;path&quot;, function(x) standardGeneric(&quot;path&quot;))</code></pre>
<pre><code>## [1] &quot;path&quot;</code></pre>
<pre class="r"><code>setGeneric(&quot;path&lt;-&quot;, function(x, value) standardGeneric(&quot;path&lt;-&quot;))</code></pre>
<pre><code>## [1] &quot;path&lt;-&quot;</code></pre>
<p>We now have a bunch of generics next we need to create methods for our Turtle.
Let‚Äôs start simple with our getter functions. To create a method, we use
<code>setMethod</code> with
:
* the name of our generic
* an argument called ‚Äòsignature‚Äô, that tells us the class the generic will dispatch on
* a function that tells us what the method does</p>
<pre class="r"><code>setMethod(&quot;location&quot;, signature = &quot;Turtle&quot;, function(x) x@location)
setMethod(&quot;orientation&quot;, signature = &quot;Turtle&quot;, function(x) x@orientation)
setMethod(&quot;path&quot;, signature = &quot;Turtle&quot;, function(x) x@path )</code></pre>
<p>We can also create our replacement methods, these will update each slot.
A turtle‚Äôs orientation and path are always updated relative to where
they already are positioned.</p>
<pre class="r"><code>setMethod(&quot;location&lt;-&quot;, signature = &quot;Turtle&quot;, function(x, value) {
  x@location &lt;- value
  stopifnot(validObject(x))
  x
})

setMethod(&quot;orientation&lt;-&quot;, signature = &quot;Turtle&quot;, function(x, value) {
  x@orientation &lt;- orientation(x) + value
  stopifnot(validObject(x))
  x
})

setMethod(&quot;path&lt;-&quot;, &quot;Turtle&quot;, function(x, value) {
  x@path &lt;- rbind(path(x), matrix(value, ncol = 2))
  stopifnot(validObject(x))
  x
})</code></pre>
<p>Now we can implement methods for forward and turn:</p>
<pre class="r"><code>setMethod(&quot;forward&quot;, signature = &quot;Turtle&quot;,
          function(x, steps) {
            location &lt;- location(x)
            angle &lt;- orientation(x) * pi / 180
            x_dir &lt;- steps * cos(angle)
            y_dir &lt;- steps * sin(angle)
            
            new_location &lt;- c(location[1] + x_dir, 
                              location[2] + y_dir)
            
            location(x) &lt;- new_location
            path(x) &lt;- new_location
            
            x
          })

setMethod(&quot;turn&quot;, &quot;Turtle&quot;, function(x, angle) {
  orientation(x) &lt;- angle
  x
})</code></pre>
<p>Most of the time, you probably don‚Äôt need a new generic function but rather
to reuse an existing one (for Bioconductor packages generic functions are
contained in the <code>BiocGenerics</code> package) by setting a method for your class.
For example, maybe we want a prettier printing method for our turtle, for
S4 classes, the print method is called ‚Äúshow‚Äù:</p>
<pre class="r"><code>setMethod(&quot;show&quot;, &quot;Turtle&quot;,
          function(object) {
            utf8::utf8_print(paste(&quot;\U1F422&quot;,
                                   paste(&quot;Located at:&quot;, paste(round(location(object), 1), collapse = &quot;,&quot;)),
                                   paste(&quot;Facing:&quot;, orientation(object), &quot;degrees&quot;),
                                   collapse = &quot;\n&quot;))
          })

lil_turtle</code></pre>
<pre><code>## [1] &quot;üê¢‚Äã Located at: 0,0 Facing: 0 degrees&quot;</code></pre>
<p>When designing a new class it‚Äôs a good idea to target methods for generic
functions in the base API. This ensures portability of your code and
means that your class behaves in a way that is already familiar to a user.</p>
<p>Now we have implemented enough methods to make our turtle move, we can start
getting our turtle to move around in 2-d! For example, we could move in
a triangle:</p>
<pre class="r"><code>library(magrittr)
turtle &lt;- Turtle()

turtle &lt;- turtle %&gt;% 
  turn(angle = 60) %&gt;% 
  forward(steps = 3) %&gt;%
  turn(angle = -120) %&gt;% 
  forward(steps = 3) %&gt;% 
  turn(angle = -120) %&gt;% 
  forward(steps = 3)

turtle </code></pre>
<pre><code>## [1] &quot;üê¢‚Äã Located at: 0,0 Facing: -180 degrees&quot;</code></pre>
<pre class="r"><code>path_taken &lt;- path(turtle)
plot(path_taken)
segments(path_taken[1:3,1], 
         path_taken[1:3,2], 
         path_taken[2:4, 1], 
         path_taken[2:4, 2])</code></pre>
<p><img src="/post/2019-07-02-s4-a-short-guide-for-perplexed_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
</div>
<div id="principle-3-designing-is-hard-reuse-instead" class="section level2">
<h2>Principle 3: designing is hard, reuse instead!</h2>
<blockquote class="twitter-tweet">
<p lang="en" dir="ltr">
If you're going to have a big multi-site collaboration, the language you're going to use isn't what you need to agree on. They key is stadardizing data structures. - Robert Gentleman <a href="https://twitter.com/hashtag/Bioc2019?src=hash&amp;ref_src=twsrc%5Etfw">#Bioc2019</a> <a href="https://twitter.com/hashtag/RGentlemanSymposium?src=hash&amp;ref_src=twsrc%5Etfw">#RGentlemanSymposium</a>
</p>
‚Äî Gabe Becker (<span class="citation">@groundwalkergmb</span>) <a href="https://twitter.com/groundwalkergmb/status/1144325071672107008?ref_src=twsrc%5Etfw">June 27, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>In R there is usually package for the task you would like to perform.
Similarly, when using S4 somebody has probably done the hard work of designing
a class related to an analysis or problem at hand. In Bioconductor, the
community has standardised core data structures related to all aspects of ‚Äòomics‚Äô,
with two key examples being the <code>SummarizedExperiment</code> and <code>Ranges</code> classes.
Instead of inventing your own class
you can extend (or just use) other package‚Äôs data structures. If the class
has been implemented well, you won‚Äôt have to go through the boring process
of implementing an interface like setters or getters.</p>
<p>Let‚Äôs extend our Turtle class, to a Turtle that‚Äôs holding a pen. A turtle
holding a pen will include three new slots: colour, thickness, and an on/off switch.</p>
<pre class="r"><code>setClass(&quot;TurtleWithPen&quot;, 
         slots = c(colour = &quot;character&quot;, thickness = &quot;numeric&quot;, on = &quot;logical&quot;),
         contains = &quot;Turtle&quot;)</code></pre>
<p>The argument <code>contains = "Turtle"</code> tells <code>setClass</code> we are inheriting
from the <code>Turtle</code> class. A <code>TurtleWithPen</code> is still a <code>Turtle</code> but has
additional slots corresponding to a Pen. We can write a constructor
for a Turtle holding a pen:</p>
<pre class="r"><code>TurtleWithPen &lt;- function(x, colour = &quot;pink&quot;, thickness = 1, on = FALSE) {
  new(&quot;TurtleWithPen&quot;, colour = colour, thickness = thickness, on = on, x)
}

turtle &lt;- TurtleWithPen(Turtle())
turtle</code></pre>
<pre><code>## [1] &quot;üê¢‚Äã Located at: 0,0 Facing: 0 degrees&quot;</code></pre>
<pre class="r"><code>class(turtle)</code></pre>
<pre><code>## [1] &quot;TurtleWithPen&quot;
## attr(,&quot;package&quot;)
## [1] &quot;.GlobalEnv&quot;</code></pre>
<p>Our <code>TurtleWithPen</code> inherits all the methods associated with Turtle, including
<code>show</code> which is why the displayed object looks the same. All the same moves
we made with an ordinary turtle can be made by one holding a pen:</p>
<pre class="r"><code>turtle %&gt;% 
  turn(angle = 60) %&gt;% 
  forward(steps = 3) %&gt;%
  turn(angle = -120) %&gt;% 
  forward(steps = 3) %&gt;% 
  turn(angle = -120) %&gt;% 
  forward(steps = 3)</code></pre>
<pre><code>## [1] &quot;üê¢‚Äã Located at: 0,0 Facing: -180 degrees&quot;</code></pre>
<p>Now we want to modify the <code>show</code> method, if the pen is on,
then will animate the Turtle‚Äôs path, otherwise we will show the Turtle
has normal.</p>
<pre class="r"><code>setMethod(&quot;show&quot;, &quot;TurtleWithPen&quot;, 
          function(object) {
            if (object@on) {
              path &lt;- path(object)
              colnames(path) &lt;- c(&quot;x&quot;, &quot;y&quot;)
              path_tbl &lt;- data.frame(path, id = seq_len(nrow(path)))
              plot &lt;- ggplot2::ggplot(data = path_tbl) + 
                ggplot2::geom_path(ggplot2::aes(x, y), 
                                   colour = object@colour, 
                                   size = object@thickness) +
                ggplot2::theme_void() + 
                gganimate::transition_reveal(id)
              gganimate::animate(plot)
            } else {
              callNextMethod()
            }
          })</code></pre>
<p>Now the show method will animate, if the pen is switched on, otherwise
we will call the next method.</p>
<p>We can try this out by having our Turtle walk through an equilateral triangle:</p>
<pre class="r"><code>pendown &lt;- function(x) {
  x@on &lt;- TRUE
  x
}
penup &lt;- function(x) {
  x@on &lt;- FALSE
  x
}

turtle &lt;- turtle %&gt;% 
  pendown() %&gt;% 
  turn(angle = 60) %&gt;% 
  forward(steps = 3) %&gt;%
  turn(angle = -120) %&gt;% 
  forward(steps = 3) %&gt;% 
  turn(angle = -120) %&gt;% 
  forward(steps = 3)


turtle %&gt;% 
  show()</code></pre>
<p><img src="/post/2019-07-02-s4-a-short-guide-for-perplexed_files/figure-html/unnamed-chunk-19-1.gif" /><!-- --></p>
<p>But if we put the pen up, then we get the usual <code>show</code> method:</p>
<pre class="r"><code>turtle %&gt;% 
  penup() </code></pre>
<pre><code>## [1] &quot;üê¢‚Äã Located at: 0,0 Facing: -180 degrees&quot;</code></pre>
<pre><code>## üê¢ Located at: 0,0 Facing: -180 degrees</code></pre>
</div>
<div id="wrapping-up" class="section level2">
<h2>Wrapping up</h2>
<p>The somewhat silly turtle graphics example has been my attempt at
demystifying S4 programming:</p>
<ul>
<li>S4 classes by themselves are just data, to compute with them you need to write methods.</li>
<li>Methods are just functions that are set on a class and are constructed from generic functions.</li>
<li>Reusing classes and methods enable a user and developer to minimise code de-duplication via inheritance.</li>
</ul>
<pre class="r"><code>star_pupil &lt;- TurtleWithPen(Turtle(c(30,30), -100), 
                            colour = &quot;green&quot;, thickness = 2) 

draw_star &lt;- function(x) {
  x &lt;- forward(x, steps = 30)
  for (i in 1:8) {
    x &lt;- turn(x, angle = 140)
    x &lt;- forward(x, steps = 30)
    x &lt;- turn(x, angle = -100)
    x &lt;- forward(x, steps = 30)
  }
  x &lt;- turn(x, angle = 140)
  forward(x, steps = 30)
}

star_pupil %&gt;% 
  pendown() %&gt;% 
  draw_star() %&gt;% 
  show()</code></pre>
<p><img src="/post/2019-07-02-s4-a-short-guide-for-perplexed_files/figure-html/bonus-star-1.gif" /><!-- --></p>
<div id="where-to-find-out-more" class="section level3">
<h3>Where to find out more?</h3>
<p>This post has barely scratched the surface of what S4 can do. We haven‚Äôt
really touched on the ideas of multiple inheritance or multiple dispatch. Hopefully
though if you‚Äôre new to S4, the ideas behind it are a little less scary!</p>
<p>There are several resources for learning more about S4:</p>
<ul>
<li><p>These <a href="https://bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html">course</a> notes by Martin Morgan and Herv√® Pag√®s go into detail about
what you need to use S4 in a package.</p></li>
<li><p>Hadley Wickham‚Äôs Advanced R book has a section on <a href="http://adv-r.had.co.nz/S4.html">S4</a> (and <a href="https://adv-r.hadley.nz/s4.html">here</a>) and other types of object-oriented programming in R.</p></li>
<li><p>If you want to get into the nitty-gritty technicalities
of S4 programming, take a look at John Chamber‚Äôs
<a href="https://www.springer.com/gp/book/9780387759357">Software for Data Analysis</a>.</p></li>
<li><p>Looking in the wild. Two examples of non-Bioconductor packages that make use of S4 are
the <a href="https://cran.r-project.org/web/packages/Matrix/index.html"><code>Matrix</code></a> and <a href="https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started"><code>rstan</code></a>.</p></li>
</ul>
</div>
</div>
